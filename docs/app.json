[{"name":"app.R","content":"# 1.0 Libraries ----\r\n\r\nlibrary(shiny)\r\nlibrary(shinyWidgets)\r\nlibrary(shinythemes)\r\nlibrary(shinydashboard)\r\nlibrary(shinydashboardPlus)\r\nlibrary(tidyverse)\r\nlibrary(tidymodels)\r\nlibrary(bslib)\r\nlibrary(shinylive)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 2.0 Loading Files ----\r\n\r\n\r\nall_iris_recipes <- read_rds(\"Iris_Models/iris_recipes_tbl.rds\")\r\nall_iris_models <- read_rds(\"Iris_Models/iris_models_tbl.rds\")\r\n\r\n\r\n# 3.0 UI ----\r\nui <- fluidPage(\r\n  \r\n  theme = shinytheme(\"superhero\"),\r\n  \r\n  titlePanel(\"Iris Classification Using Tidymodels\"),\r\n  \r\n  box(\r\n    title = \"Inputs for Classification Model\",\r\n    width = 12,\r\n    status = \"primary\",\r\n    p(\"Enter an appropriate value in each box within the range provided\"),\r\n    numericInput(\r\n      inputId = \"sepalLength\",\r\n      label   = \"Sepal.Length\",\r\n      value   = min(iris$Sepal.Length),\r\n      min     = min(iris$Sepal.Length),\r\n      max     = max(iris$Sepal.Length),\r\n      # Controls the interval by which the value will increase or decrease when you press the up/down arrow\r\n      step    = 0.5\r\n    ),\r\n    helpText(\r\n      paste(\r\n        \"The allowed range for Sepal Length is:\",\r\n        paste0(\"\", min(iris$Sepal.Length), \" to \", max(iris$Sepal.Length), \"\")\r\n      )\r\n    ),\r\n    numericInput(\r\n      inputId = \"sepalWidth\",\r\n      label   = \"Sepal.Width\",\r\n      value   = min(iris$Sepal.Width),\r\n      min     = min(iris$Sepal.Width),\r\n      max     = max(iris$Sepal.Width),\r\n      step    = 0.5\r\n    ),\r\n    helpText(\r\n      paste(\r\n        \"The allowed range for Sepal Width is:\",\r\n        paste0(\"\", min(iris$Sepal.Width), \" to \", max(iris$Sepal.Width), \"\")\r\n      )\r\n    ),\r\n    numericInput(\r\n      inputId = \"petalLength\",\r\n      label   = \"Petal.Length\",\r\n      value   = min(iris$Petal.Length),\r\n      min     = min(iris$Petal.Length),\r\n      max     = max(iris$Petal.Length),\r\n      step    = 0.5\r\n    ),\r\n    helpText(\r\n      paste(\r\n        \"The allowed range for Petal Length is:\",\r\n        paste0(\"\", min(iris$Petal.Length), \" to \", max(iris$Petal.Length), \"\")\r\n      )\r\n    ),\r\n    numericInput(\r\n      inputId = \"petalWidth\",\r\n      label   = \"Petal.Width\",\r\n      value   = min(iris$Petal.Width),\r\n      min     = min(iris$Petal.Width),\r\n      max     = max(iris$Petal.Width),\r\n      step    = 0.5\r\n    ),\r\n    helpText(\r\n      paste(\r\n        \"The allowed range for Petal Width is:\",\r\n        paste0(\"\", min(iris$Petal.Width), \" to \", max(iris$Petal.Width), \"\")\r\n      )\r\n    )\r\n  ),\r\n  br(),\r\n  # Text output to display selected values\r\n  textOutput(\"result\"),\r\n  br(),\r\n  p(\"When you are done entering the model inputs, please click 'Apply Model' below to retrieve the results\"),\r\n  actionButton(\r\n    inputId = \"apply_button\", \r\n    label = \"Apply Model\", \r\n    icon = icon(\"play\")\r\n  ),\r\n  box(\r\n    title = \"Output of Classification Model\",\r\n    width = 12,\r\n    status = \"primary\",\r\n    # Table to display model output\r\n    tableOutput(outputId = \"model_result\")\r\n  )\r\n)\r\n\r\n\r\n\r\n\r\n# 4.0 Server ----\r\nserver <- function(input, output, session) {\r\n  \r\n  # Here we begin with extracting the specific recipe you want (e.g., RECIPE_01)\r\n  recipe_list <- all_iris_recipes %>% \r\n    filter(recipe_id == \"RECIPE_01\") %>% \r\n    pull(recipe_object)\r\n  \r\n  # Here we extract the actual recipe object\r\n  iris_recipe <- recipe_list[[1]]\r\n  \r\n  \r\n  \r\n  output$result <- renderText({\r\n    paste(\r\n      \"You selected:\",\r\n      paste(\"Sepal.Length =\", input$sepalLength),\r\n      paste(\"| Sepal.Width =\", input$sepalWidth),\r\n      paste(\"| Petal.Length =\", input$petalLength),\r\n      paste(\"| Petal.Width =\", input$petalWidth)\r\n    )\r\n  })\r\n  \r\n  \r\n  # A reactiveVal to store the data table once user clicks the button\r\n  user_data <- reactiveVal(NULL)\r\n  \r\n  \r\n  # When the user clicks \"Apply Model\", generate a tibble of current input values\r\n  observeEvent(input$apply_button, {\r\n    \r\n    df <- tibble(\r\n      Sepal.Length = input$sepalLength,\r\n      Sepal.Width  = input$sepalWidth,\r\n      Petal.Length = input$petalLength,\r\n      Petal.Width  = input$petalWidth\r\n    )\r\n    \r\n    user_data(df)\r\n    \r\n    # Apply the recipe to the new data (bake it)\r\n    preprocessed_new_data <- bake(iris_recipe, user_data())\r\n    \r\n    new_predictions_tbl <- all_iris_models %>%\r\n      mutate(species_predictions = map(model_name, predict, new_data = preprocessed_new_data)) %>%\r\n      unnest(species_predictions)\r\n    \r\n    \r\n    # Here we are just extracting the predicted species based on the user data\r\n    just_predictions_tbl <- new_predictions_tbl %>%\r\n      select(.pred_class) %>%\r\n      rename(\"Predicted Species\" = .pred_class)\r\n    # This will return the actual value and not a tibble\r\n    # pluck(1)\r\n    \r\n    \r\n    # Here we are showing the predicted species based on the custom user inputs\r\n    output$model_result <- renderTable({\r\n      \r\n      just_predictions_tbl\r\n      \r\n    })\r\n    \r\n  })\r\n  \r\n  \r\n  \r\n}\r\n\r\n\r\n\r\n\r\n# 5.0 Run the App ----\r\nshinyApp(ui, server)\r\n\r\n\r\n\r\n","type":"text"},{"name":"README.md","content":"# iris_classification_shinylive\r\nDeploying a machine learning classification model publicly using shinylive\r\n","type":"text"},{"name":"iris_classification_script.R","content":"# 1.0 Libraries Needed ----\r\n\r\n\r\nlibrary(tidymodels)\r\nlibrary(readr)\r\n\r\n\r\n\r\n\r\n# 2.0 Importing Data  ----\r\n\r\n\r\n# Load the iris dataset\r\niris_raw <- iris\r\n\r\n# Checking the see the unique values in the Species column since that is our target variable and it's classification, not prediction so that matters.\r\n# Levels: setosa versicolor virginica\r\nunique(iris_raw$Species)\r\n\r\n\r\n# 3.0 Splitting the Data  ----\r\n\r\n# Splitting into training and test sets helps to prevent overfitting and improve model generalization\r\n# This then allows the model to perform well on future data\r\n# Even better is cross-validation\r\n# We'll split the iris dataset into training and testing sets.\r\n\r\n# set.seed() is used to make random processes reproducible\r\nset.seed(123) \r\n\r\n# initial_split() returns a split object with training and test sets and comes from rsample\r\n# We will split it 80-20 with 80% going to the training set and 20% going to the test set\r\n# The strata argument causes the random sampling to be conducted within the stratification variable\r\n# This can help ensure that the number of data points in the analysis data is equivalent to the proportions in the original data set\r\n# For example, the Species feature has three levels, so a random split may not account for all of them in the training set, which is bad.\r\n# We can try to prevent this by adding Species as a stratification variable\r\niris_split <- initial_split(\r\n  iris_raw, \r\n  prop = 0.8, \r\n  strata = Species)\r\n\r\n# 120 data points went to the training set. 30 data points went to the test set. There are 150 points total\r\n# <Training/Testing/Total>\r\n#   <120/30/150>\r\niris_split\r\n\r\n# training() returns the training dataset from the rsample split object\r\n# Here we get a 120x5 tibble\r\niris_train <- training(iris_split)\r\n\r\n# testing() returns the test dataset from the rsample split object\r\n# Here we get a 30x5 tibble\r\niris_test <- testing(iris_split)\r\n\r\n# Here we are simply checking if our stratification worked\r\n# We have all 3 Species in the training set. That's good!\r\niris_train %>%\r\n  distinct(Species)\r\n\r\n# We have all 3 Species in the test set. That's good!\r\niris_test %>%\r\n  distinct(Species)\r\n\r\n\r\n\r\n\r\n# 4.0 Preprocessing the Data  ----\r\n\r\n# recipe, step, prep, and bake are all important methods in the recipe library\r\n# recipe() initializes a recipe object with a formula that identifies the target variable and predictors.\r\n# It also includes the data from which to calculate the recipe from\r\n\r\n# We'll create a preprocessing recipe that normalizes the numeric features.\r\niris_recipe <- recipe(Species ~ ., data = iris_train) %>%\r\n  # normalize numeric predictors\r\n  step_normalize(all_predictors()) %>%\r\n  # prep() will perform initial calculations prior to applying the recipe\r\n  # It trains the recipe\r\n  # Steps should be added before prep()\r\n  prep()\r\n\r\n# bake() applies the prepared recipe to a dataset, performing the transformation\r\n# We get a 120 x 5 tibble\r\niris_recipe_baked <- bake(iris_recipe, iris_train)\r\n\r\n\r\n# tidy(recipe) returns information on all of the steps\r\n# So as you can see we have 1 step in our recipe\r\n# A tibble: 1 x 6\r\n# number operation type      trained skip  id             \r\n# <int> <chr>     <chr>     <lgl>   <lgl> <chr>          \r\n#   1   step      normalize TRUE    FALSE normalize_TYDox\r\ntidy(iris_recipe)\r\n\r\n\r\n# Here we will \"bake\" our recipe on the train and test sets we created\r\n# So train_transformed_tbl is a 77 x 37 tibble\r\n# Our original training set was 77 x 14, but all the preprocessing steps we added ended up creating many new features\r\ntrain_transformed_tbl <- bake(iris_recipe, iris_train)\r\n\r\n# So test_transformed_tbl is a 20 x 37 tibble\r\ntest_transformed_tbl <- bake(iris_recipe, iris_test)\r\n\r\n\r\n\r\n\r\n# 5.0 Define the Model ----\r\n\r\n# Here we are building a Random Forest model to predict the Iris species. \r\niris_rf_model <- rand_forest(mtry = 2, trees = 500) %>%\r\n  set_engine(\"ranger\") %>%\r\n  set_mode(\"classification\") %>%\r\n  fit(Species ~ ., data = train_transformed_tbl)\r\n\r\n\r\n\r\n\r\n# 6.0 Create a Workflow ----\r\n\r\n# Combine the recipe and model into a workflow.\r\n# iris_workflow <- workflow() %>%\r\n#   add_model(rf_model) %>%\r\n#   add_recipe(iris_recipe)\r\n\r\n\r\n\r\n\r\n# 7.0 Fit the Model ----\r\n\r\n# Fit the model to the training data.\r\n# iris_fit <- iris_workflow %>%\r\n#   fit(data = iris_train)\r\n\r\n\r\n\r\n\r\n# 8.0 Evaluate the Model ----\r\n\r\n# Predict on the test set and evaluate the modelâ€™s accuracy.\r\n# Predict on test data\r\niris_rf_model_predictions <- iris_rf_model %>%\r\n  predict(new_data = test_transformed_tbl) %>%\r\n  rename(\"Species Predicted\" = .pred_class) %>%\r\n  bind_cols(iris_test %>% select(Species)) \r\n\r\n# Evaluate the performance\r\niris_rf_metrics <- iris_rf_model_predictions %>%\r\n  metrics(truth = Species, estimate = `Species Predicted`)\r\n\r\n# A tibble: 2 x 3\r\n#     .metric  .estimator .estimate\r\n#     <chr>    <chr>          <dbl>\r\n#   1 accuracy multiclass     0.933\r\n#   2 kap      multiclass     0.9 \r\nprint(iris_rf_metrics)\r\n\r\n# You can also evaluate the model using a confusion matrix.\r\niris_conf_mat <- iris_rf_model_predictions %>%\r\n  conf_mat(truth = Species, estimate = `Species Predicted`)\r\n\r\n\r\n# Truth\r\n# Prediction   setosa versicolor virginica\r\n# setosa         10          0         0\r\n# versicolor      0         10         2\r\n# virginica       0          0         8\r\nprint(iris_conf_mat)\r\n\r\n\r\n\r\n\r\n# 9.0 Saving the Model ----\r\n\r\n\r\n# Here we will create a list of all the models we created\r\ntotal_models_tbl <- list(\r\n  \"MODEL_01__RF_RANDOMFOREST\" = iris_rf_model\r\n) %>%\r\n  # enframe() turns a list into a data frame\r\n  # So now we have 1x2 tibble with a column named \"name\" with model names\r\n  # We have another column called \"value\" with the actual model inside it (nested)\r\n  # We changed the column names to model_id and model_name\r\n  enframe(name = \"model_id\", value = \"model_name\")\r\n\r\n\r\n# Here we are providing a path for where to save our models\r\n# So we are adding it to the Iris_Models folder we just created\r\n# And we are going to call our data frame full of models iris_models_tbl.rds\r\ntotal_models_tbl %>% write_rds(\"Iris_Models/iris_models_tbl.rds\") \r\n\r\n\r\n\r\n# Here we will create a list of all the recipes we created\r\n# We only created one in this project\r\ntotal_recipes_tbl <- list(\r\n  \"RECIPE_01\" = iris_recipe) %>%\r\n  # We get a 1x2 tibble\r\n  enframe(name = \"recipe_id\", value = \"recipe_object\")\r\n\r\n\r\n# Here we are providing a path for where to save our recipe\r\n# So we are adding it to the Iris_Models folder we just created\r\n# And we are going to call our dataframe with our one recipe recipes_tbl.rds\r\ntotal_recipes_tbl %>% write_rds(\"Iris_Models/iris_recipes_tbl.rds\")\r\n\r\n\r\n\r\n# 10.0 Reading In Models ----\r\n\r\n# Here we are reading in the items we saved\r\nall_iris_models <- read_rds(\"Iris_Models/iris_models_tbl.rds\")\r\nall_iris_recipes <- read_rds(\"Iris_Models/iris_recipes_tbl.rds\")\r\n\r\n\r\n\r\n# 11.0 Applying Read-In Model to New Data ----\r\n\r\n\r\n# Here we will create a new Iris plant \r\nnew_iris_plant <- tibble(\r\n  Sepal.Length      = 5.8,\r\n  Sepal.Width       = 2.9,\r\n  Petal.Length      = 4.2,\r\n  Petal.Width       = 0.9\r\n) \r\n\r\n\r\n# Now we will use all of our models to predict the price of the made up bike model we created\r\nfull_predictions_tbl <- all_iris_models %>%\r\n  mutate(species_predictions = map(model_name, predict, new_data = new_iris_plant)) %>%\r\n  unnest(species_predictions)\r\n\r\n# A tibble: 1 x 3\r\n#     model_id                  model_name .pred_class\r\n#     <chr>                     <list>     <fct>      \r\n#   1 MODEL_01__RF_RANDOMFOREST <fit[+]>   virginica \r\nfull_predictions_tbl\r\n\r\njust_predictions_tbl <- full_predictions_tbl %>%\r\n  select(.pred_class)\r\n\r\n\r\n# 12.0 Testing Things Out Before API ----\r\n\r\n\r\n# Here we will create a new Iris plant \r\nnew_iris_plant <- tibble(\r\n  Sepal.Length      = 5.8,\r\n  Sepal.Width       = 2.9,\r\n  Petal.Length      = 4.2,\r\n  Petal.Width       = 0.9\r\n)\r\n\r\n\r\n# Here we begin with extracting the specific recipe you want (e.g., RECIPE_01)\r\nrecipe_list <- all_iris_recipes %>% \r\n  filter(recipe_id == \"RECIPE_01\") %>% \r\n  pull(recipe_object)\r\n\r\n# Here we extract the actual recipe object\r\niris_recipe <- recipe_list[[1]]\r\n\r\n# Apply the recipe to the new data (bake it)\r\npreprocessed_new_data <- bake(iris_recipe, new_iris_plant)\r\n\r\nnew_predictions_tbl <- all_iris_models %>%\r\n  mutate(species_predictions = map(model_name, predict, new_data = preprocessed_new_data)) %>%\r\n  unnest(species_predictions)\r\n\r\n# A tibble: 1 x 3\r\n#   model_id                  model_name .pred_class\r\n#   <chr>                     <list>     <fct>      \r\n#   1 MODEL_01__RF_RANDOMFOREST <fit[+]>   versicolor\r\nnew_predictions_tbl\r\n\r\n\r\n\r\n","type":"text"},{"name":"iris_classification_shinylive.Rproj","content":"Version: 1.0\r\n\r\nRestoreWorkspace: Default\r\nSaveWorkspace: Default\r\nAlwaysSaveHistory: Default\r\n\r\nEnableCodeIndexing: Yes\r\nUseSpacesForTab: Yes\r\nNumSpacesForTab: 2\r\nEncoding: UTF-8\r\n\r\nRnwWeave: Sweave\r\nLaTeX: pdfLaTeX\r\n","type":"text"}]
